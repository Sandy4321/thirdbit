---
layout: default
permalink: /ideas/
---
<div class="well">
  
<h1>Talks</h1>

<p><a href="{{site.github.url}}/img/gvwilson-tgac-2014-large.jpg"><img src="{{site.github.url}}/img/gvwilson-tgac-2014-small.png" alt="Greg Wilson" /></a></p>

<h2><a href="{{site.github.url}}/greatest-hits/">Software Engineering's Greatest Hits</a></h2>

<p>
  Software engineering is in the process of turning itself into an
  evidence-based research discipline.  This talk describes how that is
  happening, why it matters, and a few of the more interesting,
  surprising, and controversial results to date.
</p>

<p>
  <em>
    Last updated: March 2017.
    This talk is an update of one given at <a href="https://vimeo.com/9270320">CUSEC 2010</a>.
  </em>
</p>

<h2><a href="{{site.github.url}}/lessons-learned/">Software Carpentry: Lessons Learned</a></h2>

<p>
  Since its start in 1998, Software Carpentry has evolved from a
  week-long training course at the US national laboratories into a
  worldwide volunteer effort to improve researchers' computing
  skills. This talk will explore the lessons we've learned along the
  way about applying open source software development techniques to
  teaching at scale, and about getting people and institutions to
  change the way they work.
</p>

<p>
  <a href="http://media.ischool.illinois.edu/dl/events/cirss/wilson_sep24_16.mp4">Video from University of Illinois</a>, Sept 15, 2016
</p>

<p>
  <em>Last updated: October 2016</em>
</p>

<h2><a href="{{site.github.url}}/not-in-the-calendar/">Not in the Calendar</a></h2>

<p>
  Hundreds of books about writing compilers are currently on the
  market, but there are only three about writing debuggers.  Everyone
  thinks we should teach children how to program, but undergraduate
  courses on computing education are practically nonexistent.  This
  talk explores what these gaps and others in undergraduate Computer
  Science courses tell us about the state of computing today, and
  about how we could fix it.
</p>

<p>
  <em>Last updated: October 2016</em>
</p>

<h1>Projects</h1>

<dl>

<dt>An undergraduate course in empirical software engineering</dt>
<dd>
  <p>
    <a href="http://third-bit.com/2014/10/02/a-better-software-engineering-course.html">This post</a> describes the idea,
    and <a href="http://third-bit.com/2015/11/29/exaptation.html">this one</a> explains why the time is right.
  </p>
</dd>

<dt>Teach programmers how to run grassroots get-into-coding groups</dt>
<dd>
  <p>
    Ironically,
    programmers create get-into-coding groups so that people won't have to teach themselves how to write Javascript,
    but then reinvent all the wheels when it comes to teaching, running a non-profit, or organizing a community.
    I think it would be cool to combine the <a href="http://swcarpentry.github.io/instructor-training">Software Carpentry instructor training course</a>
    with material on <a href="https://www.amazon.com/Building-Powerful-Community-Organizations-Personal/dp/0977151808/">building community organizations</a>
    to fill in those gaps.
  </p>
</dd>

<dt><a href="https://www.amazon.com/Discussion-Book-Great-People-Talking/dp/1119049717/"><em>The Discussion Book</em></a> online</dt>
<dd>
  <p>
    Today's MOOC platforms use the Internet like television.
    What would they look like if they directly supported some of the techniques described in
    <a href="https://www.amazon.com/Discussion-Book-Great-People-Talking/dp/1119049717/">this useful book</a>?
  </p>
</dd>

<dt><a href="http://third-bit.com/browsercast/">Browsercast</a></dt>
<dd>
  <p>
    Allow people to create synchronized voiceovers for HTML slideshows.
    I've had several summer students take a run at this;
    the hard part is the authoring tool to add time marks,
    but as the demo linked in the title shows,
    the idea itself works.
  </p>
</dd>

<dt><a href="http://aosabook.org/en/buy.html#fh"><em>500 Lines or Less</em></a> - for science!</dt>
<dd>
  <p>
    Can you write a climate simulator in less than 500 lines of Python?
    What about constructing phylogenetic trees in less than 500 lines of R?
    This collection would show readers how science is turned into code across a broad range of disciplines.
    Each entry is 200-300 lines of scientific code,
    and another 200-300 lines showing readers how to <em>test</em> simple versions of a broad range of scientific applications.
  </p>
</dd>

<dt><em>A Hundred Broken Programs</em></dt>
<dd>
  <p>
    In the spirit of Johnson's <a href="https://www.amazon.com/GUI-Bloopers-2-0-Second-Technologies/dp/0123706432/"><em>GUI Bloopers</em></a>,
    this book teaches debugging by working through a hundred short examples,
    each showing a different kind of fault, a different method of diagnosis, or a different kind of fix.
  </p>
</dd>

<dt><em>The Encyclopedia of Error Handling</em></dt>
<dd>
  <p>
    How do programmers detect and handle errors?
    This companion to <em>A Hundred Broken Programs</em> would cover everything from type-checking during compilation
    to exception handling, rolling back transactions, and re-starting servers.
  </p>
</dd>

<dt>An Empirical Comparison of the Syntax of Python, R, MATLAB, and Julia</dt>
<dd>
  <p>
    We tried to repeat <a href="http://neverworkintheory.org/2014/01/29/stefik-siebert-syntax.html">Stefik et al's study of programming language syntax</a>
    for languages commonly used in science,
    but weren't able to get enough subjects.
    I think it's worth trying again,
    both for its own sake and to show that this kind of work can and should be done.
  </p>
</dd>

<dt><a href="https://hapgood.us/2016/05/13/choral-explanations/">Choral Explanations</a></dt>
<dd>
  <p>
    Just as MOOCs are mistakenly treating the Internet like television,
    Caulfield's notion of choral explanations has me thinking that
    I've been mistaken in trying to treat lesson construction as software development.
    A "lesson" platform that uses Stack Overflow as its model rather than GitHub or Wikipedia
    would be fascinating to explore,
    as would <a href="{{site.github.url}}/2016/09/12/collaborative-choral-software-exegesis.html">collaborative choral software exegesis</a>.
  </p>
</dd>

<dt><a href="https://blog.jonudell.net/2011/01/24/seven-ways-to-think-like-the-web/">Teaching People to Think Like the Web</a></dt>
<dd>
  <p>
    Jon Udell's <a href="https://blog.jonudell.net/elmcity-project-faq/">Elm City</a> calendar syndication project wasn't really about calendars:
    it was about teaching people how to think like the web.
    I have yet to see a better approach,
    and it would be exciting to resurrect this project and try again.
  </p>
</dd>

<dt><em>Software Tools</em> for the 21st Century</dt>
<dd>
  <p>
    I firmly believe that the Kernighan Trilogy
    (<a href="https://www.amazon.com/Software-Tools-Brian-W-Kernighan/dp/020103669X/"><em>Software Tools</em></a>,
    <a href="https://www.amazon.com/Unix-Programming-Environment-Prentice-Hall-Software/dp/013937681X/"><em>The Unix Programming Environment</em></a>,
    and <a href="https://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131103628/"><em>The C Programming Language</em></a>)
    are the main reason that Unix succeeded.
    I would really like an update that uses a modern operating system and a modern programming language (preferably functional),
    borrows heavily from <a href="https://en.wikipedia.org/wiki/PowerShell">PowerShell</a> and the like,
    and takes Udell's "seven ways" to heart.
  </p>
</dd>

<dt><a href="https://swcarpentry.github.io/managing-research-software-projects/short/"><em>Managing Research Software Projects</em></a></dt>
<dd>
  <p>
    Your graduate degree is in ecology,
    but now you're running a three-person team responsible for building and maintaining a hundred thousand lines of code?
    This book (or course, or whatever) is everything you absolutely, positively need to know
    <em>after</em> you know how to program.
    (We've <a href="https://swcarpentry.github.io/managing-research-software-projects/short/">started work</a> on this,
    but more hands would be welcome.)
  </p>
</dd>

<dt>Temporal cluster analysis to find <em>actual</em> design patterns</dt>
<dd>
  <p>
    I often use Sajaniemi et al's <a href="http://www.cs.joensuu.fi/~saja/var_roles/stud_vers/stud_Python3_eng.html">roles of variables</a> in teaching,
    but like <a href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/">the classic design patterns</a>,
    they were "discovered" by eyeballing novice code.
    I think that cluster analysis of patterns of class and variable use would uncover more patterns,
    and confirm my suspicion that some of the classics are really just different names for the same thing.
  </p>
</dd>

<dt><em>The Undergraduate Owner's Manual</em></dt>
<dd>
  <p>
    I would really like to run a one-semester course for first-year undergraduates whose subject was themselves.
    What happens in your brain when you learn something, and how can you learn more efficiently?
    What's the effect of sleep deprivation on the quality of work?
    How can you analyze the social dynamics of a classroom, or change them to make participation fairer?
    How can you run a small group project?
    Who decides what gets taught at universities and who gets to take part?
  </p>
</dd>

</dl>

<h3>Not on the Shelves</h3>

<p>
  I've written <a href="{{site.github.url}}/not-on-the-shelves/">some reviews of unwritten books...</a>
</p>

</div>
