---
layout: book
permalink: /teaching/lessons.html
title: "How to Teach Programming (and Other Things): Designing Lessons"
---
<h1 id="designing-lessons">Designing Lessons</h1>
<p><strong>Objectives</strong></p>
<ul>
<li><strong>Learners can describe the steps in reverse instructional design
and explain why it generally produces better lessons than the
usual &quot;forward&quot; lesson development process.</strong></li>
<li><strong>Learners can define &quot;teaching to the test&quot; and explain why
reverse instructional design is <em>not</em> the same thing.</strong></li>
<li><strong>Learners can construct and critique five-part learner profiles.</strong></li>
<li><strong>Learners can construct good learning objectives and critique
learning objectives with reference to Bloom&apos;s Taxonomy.</strong></li>
</ul>
<p>Most people design lessons as follows:</p>
<ol>
<li><p>Someone tells you that you have to teach something you haven&apos;t
thought about in ten years.</p>
</li>
<li><p>You start writing slides to explain what you know about the subject.</p>
</li>
<li><p>After two or three weeks, you make up an assignment based more or
less on what you&apos;ve taught so far.</p>
</li>
<li><p>You repeat step 3 several times.</p>
</li>
<li><p>You stay awake into the wee hours of the morning to create a final
exam.</p>
</li>
</ol>
<p>There&apos;s a better way, but to explain it, we first need to explain how
<em><a href="gloss.html#test-driven-development">test-driven development</a></em> (TDD)
is used in software development.  Programmers who are using TDD don&apos;t
write software and then (possibly) write tests.  Instead, they write
the tests first, then write just enough new software to make those
tests pass, and then clean up a bit.</p>
<p>TDD works because writing tests forces programmers to specify exactly
what they&apos;re trying to accomplish and what &quot;done&quot; looks like. It&apos;s
easy to be vague when using a human language like English or Korean;
it&apos;s much harder to be vague in Python or R.</p>
<p>TDD also reduces the risk of endless polishing, and also the risk of
confirmation bias: someone who hasn&apos;t written a program is much more
likely to be objective when testing it than its original author, and
someone who hasn&apos;t written a program <em>yet</em> is more likely to test
it objectively than someone who has just put in several hours of hard
work and really, really wants to be done.</p>
<p>A similar &quot;backward&quot; method works very well for lesson design.  This
method is something called <em><a href="gloss.html#reverse-instructional-design">reverse instructional
design</a></em> or <em><a href="gloss.html#understanding-by-design">understanding by
design</a></em> after a book by that name
[<a href="biblio.html#wiggins-mctighe">Wiggins2005</a>]; a similar method is
described in [<a href="biblio.html#fink-significant">Fink2013</a>] (a summary of
which is freely available online [<a href="fink-short">Fink2003</a>].)  In brief,
lessons should be designed as follows:</p>
<ol>
<li><p>Create learner profiles (discussed in the next section) to figure
out who you are trying to teach and what will appeal to them.</p>
</li>
<li><p>Draw concept maps to describe the mental model you want them to
construct.</p>
</li>
<li><p>Create a summative assessment, such as a final exam or performance,
that will show you whether learning has actually taken place.</p>
</li>
<li><p>Create formative assessments that will give the learners a chance to
practice the things they&apos;ll be asked to demonstrate in the summative
assessment, and tell you and them whether they&apos;re making progress
and where they need to focus their work.</p>
</li>
<li><p>Put the formative assessments in order based on their complexity and
dependencies.</p>
</li>
<li><p>Write just enough to get learners from one formative assessment to
the next.  An actual classroom lesson will typically then consist of
three or four such episodes, each building toward a short check that
learners are keeping up.</p>
</li>
</ol>
<p>This method helps to keep teaching focused on its objectives. It also
ensures that learners don&apos;t face anything on the final exam that the
course hasn&apos;t prepared them for.</p>
<blockquote>
<p><strong>Building Lessons by Subtracting Complexity</strong></p>
<p>One way to build a programming lesson is to write the program you
want learners to finish with, then remove the most complex part that
you want them to write and make it the last exercise. You can then
remove the next most complex part you want them to write and make it
the penultimate exercise, and so on.  Anything that&apos;s left&#x2013;i.e.,
anything you don&apos;t want them to write as an exercise&#x2013;becomes the
starter file(s) that you give them.  This typically includes things
like importing libraries or helper functions to access data.</p>
</blockquote>
<!-- comment needed to separate blockquotes -->
<blockquote>
<p><strong>How and Why to Fake It</strong></p>
<p>One of the most influential papers in the history of software
engineering was Parnas and Clements&apos; &quot;A Rational Design Process: How
and Why to Fake It&quot;.  In it, the authors pointed out that in real
life we move back and forth between gathering requirements, interface
design, programming, and testing, but when we write up our work it&apos;s
important to describe it as if we did these steps one after another so
that other people can retrace our steps. The same is true of lesson
design: while we may change our mind about what we want to teach based
on something that occurs to us while we&apos;re writing an MCQ, we want the
notes we leave behind to present things in the order described above.</p>
</blockquote>
<!-- comment needed to separate blockquotes -->
<blockquote>
<p><strong>Teaching to the Test</strong></p>
<p>Reverse instructional design is <em>not</em> the same thing as &quot;teaching to
the test&quot;. When using RID, teachers set goals to aid in lesson
design, and may never actually give the final exam that they
wrote. In many school systems, on the other hand, an external
authority defines assessment criteria for all learners, regardless
of their individual situations, and the outcomes of those summative
assessments directly affect the teachers&apos; pay and promotion.
Green&apos;s <em>Building a Better Teacher</em>
[<a href="biblio.html#green-babt">Green2014</a>] argues that this focus on
measurement is appealing to those with the power to set the tests,
but is unlikely to improve outcomes unless it is coupled with
support for teachers to make improvements based on test outcomes.
This is often missing, because as Scott pointed out in
[<a href="biblio.html#scott-state">Scott1999</a>], large organizations usually
value uniformity over productivity.</p>
</blockquote>
<h2 id="learner-profiles">Learner Profiles</h2>
<p>The first piece of the process above is figuring out who your audience
is.  One way to do this is to write two or three <em><a href="gloss.html#learner-profile">learner
profiles</a></em>. This technique is borrowed
from user interface design, where short profiles of typical users are
created to help designers think about their audience&apos;s needs, and to
give them a shorthand for talking about specific cases.</p>
<p>Learner profiles have five parts: the person&apos;s general background,
what they already know, what <em>they</em> think they want to do, how
the course will help them, and any special needs they might have. A
learner profile for a weekend workshop aimed at new college students
might be:</p>
<ol>
<li><p>Jorge has just moved from Costa Rica to Canada to study agricultural
engineering.  He has joined the college soccer team, and is looking
forward to learning how to play ice hockey.</p>
</li>
<li><p>Other than using Excel, Word, and the Internet, Jorge&apos;s most
significant previous experience with computers is helping his sister
build a WordPress site for the family business back home in Costa
Rica.</p>
</li>
<li><p>Jorge needs to measure properties of soil from nearby farms using a
handheld device that sends logs in a text format to his computer.
Right now, Jorge has to open each file in Excel, crop the first and
last points, and calculate an average.</p>
</li>
<li><p>This workshop will show Jorge how to write a little Python program
to read the data, select the right values from each file, and
calculate the required statistics.</p>
</li>
<li><p>Jorge can read English proficiently, but still struggles sometimes
to keep up with spoken conversation (especially if it involves a lot
of new jargon).</p>
</li>
</ol>
<p>A single learner profile is sometimes enough, but two or three that
cover the whole range of potential learners is better.  One of the
ways they help is by serving as a shorthand for design issues: when
speaking with each other, lesson authors can say, &quot;Would Jorge
understand why we&apos;re doing this?&quot; or, &quot;What installation problems
would Jorge face?&quot;</p>
<blockquote>
<p><strong>Our Learners Revisited</strong></p>
<p>The profiles of Samira and Moshe in the <a href="./">introduction</a>
have the five points listed above, rearranged to flow more readably.</p>
</blockquote>
<h2 id="learning-objectives">Learning Objectives</h2>
<p>Summative and formative assessments help instructors figure out what
they&apos;re going to teach, but in order to communicate that to learners
and other instructors, a course description should also have
<em><a href="gloss.html#learning-objective">learning objectives</a></em> (sometimes
also called a <em>learning goal</em>). A learning objective is a single
sentence describing what a learner will be able to do once they have
sat through the lesson in order to demonstrate what they have learned.</p>
<p>Learning objectives are meant to ensure that everyone has the same
understanding of what a lesson is supposed to accomplish. For example,
a statement like &quot;understand Git&quot; could mean any of the following,
each of this would be backed by a very different lesson:</p>
<ul>
<li><p>Learners can describe three scenarios in which version control
systems like Git are better than file-sharing tools like Dropbox,
and two in which they are worse.</p>
</li>
<li><p>Learners can commit a changed file to a Git repository using a
desktop GUI tool.</p>
</li>
<li><p>Learners can explain what a detached HEAD is and recover from it
using command-line operations.</p>
</li>
</ul>
<blockquote>
<p><strong>Objectives vs. Outcomes</strong></p>
<p>A learning objective is what a lesson strives to achieve.  A
<em><a href="gloss.html#learning-outcome">learning outcome</a></em> is what it
actually achieves, i.e., what learners actually take away.  The role
of summative assessment is therefore to compare outcomes with
objectives.</p>
</blockquote>
<p>More specifically, a good learning objective has a <em>measurable or
verifiable verb</em> that states what the learner will do, and specifies
the <em>criteria for acceptable performance</em>.  Writing these kinds of
learning objectives may initially seem restrictive or limiting, but
will make both you, your fellow instructors, and your learners happier
in the long run. You will end up with clear guidelines for both your
teaching and assessment, and your learners will appreciate the clear
expectations.</p>
<p>One tool that can help when writing learning objectives is <a href="https://en.wikipedia.org/wiki/Bloom&apos;s_taxonomy" target="_blank">Bloom&apos;s
taxonomy</a>, which was first published in 1956.  It
attempts to define levels of understanding in a way that is
hierarchical, measurable, stable, and cross-cultural.  The list below
defines the levels in Bloom&apos;s Taxonomy and shows some of the verbs
typically used in learning objectives written for each level.</p>
<ul>
<li><p>Knowledge: recalling learned information
(name, define, recall).</p>
</li>
<li><p>Comprehension: explaining the meaning of information
(restate, locate, explain, recognize).</p>
</li>
<li><p>Application: applying what one knows to novel, concrete situations
(apply, demonstrate, use).</p>
</li>
<li><p>Analysis: breaking down a whole into its component parts
and explaining how each part contributes to the whole
(differentiate, criticize, compare).</p>
</li>
<li><p>Synthesis: assembling components to form a new and integrated whole
(design, construct, organize).</p>
</li>
<li><p>Evaluation: using evidence to make judgments about
the relative merits of ideas and materials (choose, rate, select).</p>
</li>
</ul>
<p>Another way to understand what makes for a good learning objective
is to see how a poor one can be improved:</p>
<ul>
<li><p>&quot;Learner will be given opportunities to learn good programming practices.&quot;
<em>Describes the lesson&apos;s content, not the attributes of successful
students.</em></p>
</li>
<li><p>&quot;Learner will have a better appreciation for good programming practices.&quot;
<em>Doesn&apos;t start with an active verb or define the level of learning,
and the subject of learning has no context and is not specific.</em></p>
</li>
<li><p>&quot;Learner will understand how to program in R.&quot;
<em>Starts with an active verb, but doesn&apos;t define the level of
learning, and the subject of learning is still too vague for
assessment.</em></p>
</li>
<li><p>&quot;Learner will write one-page read-filter-summarize-print data
analysis scripts for tabular data using R and R Studio.&quot;
<em>Starts with an active verb, defines the level of learning,
and provides context to ensure that outcomes can be assessed.</em></p>
</li>
</ul>
<p>Baume&apos;s guide to writing and using good learning outcomes
[<a href="biblio.html#baume-outcomes">Baume2009</a>] is a good longer discussion of
these issues.</p>
<h2 id="challenges">Challenges</h2>
<h3 id="learner-profiles-30-minutes">Learner Profiles (30 minutes)</h3>
<p>Working in pairs or small groups, create a five-point profile that
describes one of your typical learners.</p>
<h3 id="write-learning-objectives-20-minutes">Write Learning Objectives (20 minutes)</h3>
<p>Write one more learning objectives for something you currently teach
or plan to teach.  Working with a partner, critique and improve the
objectives.</p>
