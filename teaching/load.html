---
layout: book
permalink: /teaching/load.html
title: "How to Teach Programming (and Other Things): Cognitive Load"
---
<h1 id="cognitive-load">Cognitive Load</h1>
<p><strong>Objectives</strong></p>
<ul>
<li><strong>Learners can define cognitive load and explain how consideration
of it can be used to shape instruction.</strong></li>
<li><strong>Learners can explain what faded examples are and construct faded
examples for use in programming workshops.</strong></li>
<li><strong>Learners can explain what Parson&apos;s Problems are and construct
Parson&apos;s Problems for use in programming workshops.</strong></li>
<li><strong>Learners can describe ways in which they differ from their own
learners and what effect those differences have on instruction.</strong></li>
</ul>
<p>In 2006, Kirschner, Sweller, and Clark published a paper titled &quot;Why
Minimal Guidance During Instruction Does Not Work: An Analysis of the
Failure of Constructivist, Discovery, Problem-Based, Experiential, and
Inquiry-Based Teaching&quot;
[<a href="biblio.html#kirschner-minimal">Kirschner2006</a>]. Its abstract says:</p>
<blockquote>
<p>Although unguided or minimally guided instructional approaches are
very popular and intuitively appealing&#x2026;these approaches ignore both
the structures that constitute human cognitive architecture and
evidence from empirical studies over the past half-century that
consistently indicate that minimally guided instruction is less
effective and less efficient than instructional approaches that
place a strong emphasis on guidance of the student learning
process. The advantage of guidance begins to recede only when
learners have sufficiently high prior knowledge to provide
&quot;internal&quot; guidance.</p>
</blockquote>
<p>The paper set off a minor academic firestorm, because beneath the
jargon the authors were claiming that <em><a href="gloss.html#inquiry-based-learning">inquiry-based
learning</a></em> doesn&apos;t actually work
very well.  Inquiry-based learning is the practice of allowing
learners to ask their own questions, set their own goals, and find
their own path through a subject, just as they would when solving
problems in real life.  It is intuitively appealing, but Kirschner
argued that it overloads learners, since it requires them to
simultaneously master both a domain&apos;s factual content and its
problem-solving strategies.</p>
<p>More specifically, <em><a href="gloss.html#cognitive-load-theory">cognitive load
theory</a></em> posits that people have to
deal with three things when they&apos;re learning:</p>
<ol>
<li><p><em>Intrinsic</em> load is what people have to keep in mind in order to
carry out a learning task.  In a programming class, this might be
understanding what a variable is, or understanding how assignment in
a programming language is different from creating a reference to a
cell in a spreadsheet.</p>
</li>
<li><p><em>Germane</em> load is the (desirable) mental effort required to create
linkages between new information and old, which is one of the
things that distinguishes learning from memorization.  An example
might be learning how to loop through a collection in Python.</p>
</li>
<li><p><em>Extraneous</em> load is everything else that distracts or gets in
the way, such as knowing that tabs look like multiple characters but
only count as one when indenting Python code.</p>
</li>
</ol>
<p>According to this theory, searching for a solution strategy is an
extra burden on top of applying that strategy. We can therefore
accelerate learning by giving learners worked examples that show them
a problem and a detailed step-by-step solution, followed by a series
of <em><a href="gloss.html#faded-example">faded examples</a></em>. The first of these
presents a nearly-complete use of the same problem-solving strategy
just demonstrated, but with a small number of blanks for the learner
to fill in. The next problem is also of the same type, but has more
blanks, and so on until the learner is asked to solve the entire
problem.  (The material that <em>isn&apos;t</em> blank is often referred to as
<em><a href="gloss.html#scaffolding">scaffolding</a></em>, since it serves the same
purpose as the scaffolding set up temporarily at a building site.)</p>
<p>For example, someone teaching Python might start by explaining this:</p>
<pre><code># total_length([&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]) =&gt; 12
def total_length(words):
      total = 0
      for word in words:
          total += len(word)
      return total
</code></pre><!--| \noindent |-->
<p>then ask learners to fill in the blanks in:</p>
<pre><code># word_lengths([&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]) =&gt; [3, 5, 4]
def word_lengths(words):
      lengths = ____
      for word in words:
          lengths ____
      return lengths
</code></pre><!--| \newpage |-->
<!--| \noindent |-->
<p>The next problem might be:</p>
<pre><code># join_all([&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]) =&gt; &quot;redgreenblue&quot;
def join_all(words):
      result = ____
      for ____ in ____:
          ____
      return result
</code></pre><!--| \noindent |-->
<p>and learners would finally be asked to tackle:</p>
<pre><code># acronymize([&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]) =&gt; &quot;RGB&quot;
def acronymize(words):
      ____
</code></pre><p>Faded examples work because they introduce the problem-solving
strategy piece by piece. At each step, learners have one new problem
to tackle.  As <a href="practices.html#never-a-blank-page">discussed later</a>,
this is less intimidating than a blank screen or a blank sheet of
paper.  It also encourages learners to think about the similarities
and differences between various approaches, which helps create the
linkages in the mental model that instructors want them to form.</p>
<p>The key to constructing a good faded example is to think about the
problem-solving strategy or solution pattern that it is meant to
teach.  For example, the series of problems are all examples of the
<em>accumulator pattern</em>, in which the results of processing items
from a collection are repeatedly added to a single variable in some way
to create the final result.</p>
<p>Cognitive load theory has been criticized as being
<a href="https://edtechdev.wordpress.com/2009/11/16/cognitive-load-theory-failure/" target="_blank">unfalsifiable</a>: since there&apos;s no way to
tell in advance of an experiment whether something is germane or not,
any result can be justified after the fact by labelling things that
hurt performance as &quot;extraneous&quot; and things that don&apos;t &quot;germane&apos;&apos;.
However, there is no doubt that faded examples are effective.</p>
<blockquote>
<p><strong>Split Attention</strong></p>
<p>Research by Mayer and colleagues on the <a href="https://en.wikipedia.org/wiki/Split_attention_effect" target="_blank">split-attention
effect</a> is closely related to cognitive
load theory [<a href="biblio.html#mayer-nine-ways">Mayer2003</a>].  Linguistic and
visual input are processed by different parts of the human brain,
and linguistic and visual memories are stored separately as
well. This means that correlating linguistic, auditory, and visual
streams of information takes cognitive effort: when someone reads
something while hearing it spoken aloud, their brain can&apos;t help but
check that it&apos;s getting the same information on both channels.</p>
<p>Learning is therefore more effective when redundant information is
<em>not</em> presented simultaneously in two different channels. For
example, people find it harder to learn from a video that has both
narration and on-screen captions than from one that has either the
narration or the captions but not both.</p>
<p>The key word in the previous paragraph is &quot;redundant&quot;.  It turns out
that it&apos;s more effective to draw a diagram piece by piece while
teaching rather than to present the whole thing at once.  If parts
of the diagram appear at the same time as things are being said, the
two will be correlated in the learner&apos;s memory.  Pointing at part of
the diagram later is then more likely to trigger recall of what was
being said when that part was being drawn.</p>
</blockquote>
<p>Another way to use cognitive load theory to construct exercises is
called a <em><a href="gloss.html#parsons-problem">Parson&apos;s Problem</a></em>.  If you are
teaching someone to speak a new language, you could ask them a
question, and then give them the words they need to answer the
question, but in jumbled order.  Their task is to put the words in the
right order to answer the question grammatically, which frees them
from having to think simultaneously about what to say <em>and</em> how to say
it.</p>
<p>Similarly, when teaching people to program, you can give them the
lines of code they need to solve a problem, and ask them to put them
in the right order.  This allows them to concentrate on control flow
and data dependencies, i.e., on what has to happen before what,
without being distracted by variable naming or trying to remember what
functions to call.</p>
<h2 id="pattern-recognition">Pattern Recognition</h2>
<p><a href="memory.html#seven-plus-or-minus-two">An earlier section</a> described how
people chunk related or correlated information together so that they
can fit more into short-term memory.  One key finding in cognition
research is that experts have more and larger chunks than non-experts,
i.e., experts &quot;see&quot; larger patterns, and have more patterns to match
things against.  This allows them to reason at a higher level, and
to search for information more quickly and more accurately.</p>
<p>It is therefore tempting to try to teach patterns directly&#x2013;in fact,
supporting this is one of the reasons programmers have been so
enthusiastic about <a href="https://en.wikipedia.org/wiki/Software_design_pattern" target="_blank">design patterns</a>.  In
practice, though, pattern catalogs are too large to flick through and
too dry to memorize directly.  Giving names to a small number of
patterns, though, does seem to help with teaching, primarily by giving
the learners a richer vocabulary to think and communicate with
[<a href="biblio.html#kuittinen-patterns">Kuittinen2004</a>].</p>
<h2 id="you-are-not-your-learners">You Are Not Your Learners</h2>
<p>People learn best when they care about the topic and believe they can
master it. Neither fact is particularly surprising, but their
practical implications have a lot of impact on what we teach, and the
order in which we teach it.</p>
<p>First, as noted in <a href="motivation.html">Motivation</a>, most people don&apos;t
actually want to program: they want to build a website or check on
zoning regulations, and programming is just a tax they have to pay
along the way. They don&apos;t care how hash tables work, or even that hash
tables exist; they just want to know how to process data faster. We
therefore have to make sure that everything we teach is useful right
away, and conversely that we don&apos;t teach anything just because it&apos;s
&quot;fundamental&quot;.</p>
<p>Second, believing that something will be hard to learn is a
self-fulfilling prophecy. This is why it&apos;s important not to say that
something is easy: if someone who has been told that tries it, and it
doesn&apos;t work, they are more likely to become discouraged.</p>
<p>It&apos;s also why installing and configuring software is a much bigger
problem for us than experienced programmers like to acknowledge. It
isn&apos;t just the time we lose at the start of boot camps as we try to
get a Unix shell working on Windows, or set up a version control
client on some idiosyncratic Linux distribution.</p>
<p>It isn&apos;t even the unfairness of asking students to debug things that
depend on precisely the knowledge they have come to learn, but which
they don&apos;t yet have. The real problem is that every such failure
reinforces the belief that computing is hard, and that they&apos;d have a
better chance of making next Thursday&apos;s deadline at work if they kept
doing things the way they always have. For these reasons, we have
adopted a &quot;teach most immediately useful first&quot; approach described
in <a href="motivation.html">Motivation</a>.</p>
<h2 id="challenges">Challenges</h2>
<h3 id="create-a-faded-example-30-minutes">Create a Faded Example (30 minutes)</h3>
<p>It&apos;s very common for programs to count how many things fall into
different categories: for example, how many times different colors
appear in an image, or how many times different words appear in a
paragraph of text.</p>
<ol>
<li><p>Create a short example (no more than 10 lines of code) that shows
people how to do this, and then create a second example that solves
a similar problem in a similar way, but has a couple of blanks for
learners to fill in.  How did you decide what to fade out?  What
would the next example in the series be?</p>
</li>
<li><p>Define the audience for your examples. For example, are these
beginners who only know some basics programming concepts? Or are
these learners with some experience in programming but not in
Python?</p>
</li>
<li><p>Show your example to a partner, but do <em>not</em> tell them what
level it is intended for.  Once they have filled in the blanks, ask
them what level they think it is for.</p>
</li>
</ol>
<p>If there are people among the trainees who don&apos;t program at all, make
sure that they are in separate groups and ask to the groups to work
with that person as a learner to help identify different loads.</p>
<h3 id="create-a-parsons-problem-20-minutes">Create a Parson&apos;s Problem (20 minutes)</h3>
<p>Write five or six lines of code that does something useful, jumble
them, and ask your partner to put them in order.  If you are using an
indentation-based language like Python, do not indent any of the
lines; if you are using a curly-brace language like Java, do not
include any of the curly braces.</p>
